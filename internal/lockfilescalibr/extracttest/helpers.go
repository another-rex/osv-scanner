package extracttest

import (
	"cmp"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/osv-scanner/internal/lockfilescalibr/extractor"
	"github.com/google/osv-scanner/internal/lockfilescalibr/fakefs"
	"github.com/google/osv-scanner/internal/lockfilescalibr/filesystem"
	scalibrfs "github.com/google/osv-scanner/internal/lockfilescalibr/fs"
)

// ScanInputMockConfig is used to quickly configure building a mock ScanInput
type ScanInputMockConfig struct {
	// Path of the file ScanInput will read, relative to the ScanRoot
	Path string
	// FakeScanRoot allows you to set a custom scanRoot, can be relative or absolute,
	// and will be translated to an absolute path
	FakeScanRoot string
	FakeFileInfo *fakefs.FakeFileInfo
}

// TestTableEntry is a entry to pass to ExtractionTester
type TestTableEntry struct {
	Name          string
	InputConfig   ScanInputMockConfig
	WantInventory []*extractor.Inventory
	WantErr       error
}

// CloseTestScanInput takes a scan input generated by GenerateScanInputMock
// and closes the associated file handle
func CloseTestScanInput(t *testing.T, si filesystem.ScanInput) {
	t.Helper()
	// If the Reader is not an io.Closer, then there is an implementation error and this should panic.
	err := si.Reader.(io.Closer).Close()
	if err != nil {
		t.Errorf("Close(): %v", err)
	}
}

// GenerateScanInputMock will try to open the file locally, and fail if the file doesn't exist
func GenerateScanInputMock(t *testing.T, config ScanInputMockConfig) filesystem.ScanInput {
	t.Helper()

	var scanRoot string
	if filepath.IsAbs(config.FakeScanRoot) {
		scanRoot = config.FakeScanRoot
	} else {
		workingDir, err := os.Getwd()
		if err != nil {
			t.Fatalf("Can't get working directory because '%s'", workingDir)
		}
		scanRoot = filepath.Join(workingDir, config.FakeScanRoot)
	}

	f, err := os.Open(filepath.Join(scanRoot, config.Path))
	if err != nil {
		t.Fatalf("Can't open test fixture '%s' because '%s'", config.Path, err)
	}
	info, err := f.Stat()
	if err != nil {
		t.Fatalf("Can't stat test fixture '%s' because '%s'", config.Path, err)
	}

	return filesystem.ScanInput{
		FS:     os.DirFS(scanRoot).(scalibrfs.FS),
		Path:   config.Path,
		Root:   scanRoot,
		Reader: f,
		Info:   info,
	}
}

// InventoryCmpLess returns whether Inventory a is less than b.
func InventoryCmpLess(a, b *extractor.Inventory) bool {
	aLoc := fmt.Sprintf("%v", a.Locations)
	bLoc := fmt.Sprintf("%v", b.Locations)

	var aExtr, bExtr string
	if a.Extractor != nil {
		aExtr = a.Extractor.Name()
	}
	if b.Extractor != nil {
		bExtr = b.Extractor.Name()
	}

	aSourceCode := fmt.Sprintf("%v", a.SourceCode)
	bSourceCode := fmt.Sprintf("%v", b.SourceCode)

	return cmp.Or(
		cmp.Compare(aLoc, bLoc),
		cmp.Compare(a.Name, b.Name),
		cmp.Compare(a.Version, b.Version),
		cmp.Compare(aSourceCode, bSourceCode),
		cmp.Compare(aExtr, bExtr),
	) < 0
}

// ContainsErrStr is an error that matches other errors that contains
// `str` in their error string.
type ContainsErrStr struct {
	Str string
}

// Error returns the error string
func (e ContainsErrStr) Error() string { return fmt.Sprintf("error contains: '%s'", e.Str) }

// Is checks whether the input error contains the string in ContainsErrStr
func (e ContainsErrStr) Is(err error) bool {
	return strings.Contains(err.Error(), e.Str)
}
